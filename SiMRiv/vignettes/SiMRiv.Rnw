\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
%\VignetteIndexEntry{Usage of the SiMRiv package}

\newcommand{\code}[1]{{\tt #1}}

\SweaveOpts{keep.source=TRUE}

\begin{document}

<<version, include=FALSE, echo=FALSE>>=
#options(width = 60)
version <- packageDescription("SiMRiv")
#colorramp <- rgb(c(seq(4, 9, len = 5), rep(9, 5)), c(rep(9, 5), seq(9, 4, len = 5)), 0, max = 9)
#colorramp <- rgb(9, 9:0, 9:0, max = 9)
@

<<results=hide, include=FALSE, echo=FALSE>>=
my.Swd <- function(name, width, height, ...) {
  grDevices::png(filename = paste(name, "png", sep = "."),
                 width = 8, height = 8, res = 100, units = "in")
}
my.Swd.off <- function() {
    grDevices::dev.off()
}

my.Swd2 <- function(name, width, height, ...) {
  grDevices::png(filename = paste(name, "png", sep = "."),
                 width = 8, height = 8 * 2, res = 100, units = "in")
}
my.Swd2.off <- function() {
    grDevices::dev.off()
}

library(SiMRiv)
@

\title{'SiMRiv'\\(version \Sexpr{version$Version})\\An R package for simulating and modeling spatially-explicit individual multi-state (animal) movements in any landscape}
\author{Miguel Porto, Lorenzo Quaglietta}
\maketitle

\tableofcontents

\\... TBC

\section{Introduction}
The study of animal movement behaviour, recently reframed in the 'Movement Ecology' paradigm (Nathan 2008), is key to a variety of fields including landscape ecology, species distribution modeling,
and population size estimation among others (Turchin 1998; Nathan 2008; Royle et al. 2014). All the most widely adopted statistical and modeling approaches to study movement,
including Lévy walks (e.g., Humphries et al. 2010; Viswanathan 2010; Sims et al. 2008), (hidden) Markov models (e.g., Morales et al. 2004; Langrock et al. 2012; McClintock et al. 2012),
state-space models (e.g., Forester et al. 2007; Patterson et al. 2008), step (or resource) selection functions (e.g., Fortin et al. 2005; Forester et al. 2009),
mechanistic (home range) models (e.g., Mitchell \& Powell 2004; Moorcroft \& Lewis 2006), and combinations of the last two (e.g., Moorcroft \& Barnett 2008; Potts et al. 2014)
as well as to study movement-related issues in fields as varied as anthropology (Raichlen et al. 2014), paleontology (Sims et al. 2014), cell biology (Dickinson \& Tranquillo 1993),
tumour angiogenesis (Plank \& Sleeman 2003), and, increasingly often, molecular ecology (Hoban et al. 2012; Hoban 2014), lie in the mathematical analysis of random walks. As such,
they require to simulate random, spatially-explicit individual trajectories, that are then compared to real trajectories to infer the underlying movement processes. While software
for simulating individual trajectories of species that move without restrictions in the landscape (species moving in a bi-dimensional space, i.e., using the space at 360º) exist, we are aware of no
appropriate software for simulating individual movement trajectories of species inhabiting (or more intensively using) linear landscapes (e.g., trouts or otters in rivers) or somehow conditioned by landscape heterogeneity. 
SiMRiv allows such task. It was specifically conceived to allow simulating individual-based, spatially-explicit movements in river networks and heterogeneous landscapes. However, the software was thought and developed to be highly flexible,
allowing simulating trajectories of any species living in any landscape (i.e., irrespective of the landscape the species live within). It thus allows fitting realistically complex movement models, using multi-state markov models, while taking into account environmental complexity.

In this document, we: (i) introduce how to prepare the data for the simulations; (ii) report the main functionalities of the software; (iii) introduce some examples of use of the software; and (iv) provide an overview on main software's potential applications, expected outcomes,
and features we would like to modify or develop by new. We assume that you are somehow familiar with the basic concepts of Movement Ecology (see reviews on this, as well as on the use of random walk models in Ecology in Nathan 2008, Codling et al 2008, Smouse et al 2010, and Patterson et al 2016), as well as with the R language and environment. In case you need help for the 'raster' package, you may want to refer to its vignette (http://cran.r-project.org/web/packages/raster/vignettes/Raster.pdf).
This is a work in progress, \bf{report of any bug or suggestion is warmly welcomed. We are particularly interested in any collaboration, especially stemming from other programmers} who would like to add some functions to our package or extend the already implemented ones (https://github.com/miguel-porto/SiMRiv/).

\section{Conducting basic simulations}
In the simplest form, conducting simulations is straightforward. Using the default parameters setting, individuals will be simulated
in an homogeneous environment, will start at coordinates (0, 0), and have a unit step length for all states.
You only have to provide the movement type of each state. This is done by defining a \code{species}.
Let's first look at the simplest case, a simple Random Walk (cf. Turchin 1998):

<<simriv-1, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
# define a species with a single-state movement type
# characterized by a random walk
rand.walker <- species(state.RW())

# simulate one individual of this species
# 10000 simulation steps
sim.rw <- simulate(rand.walker, 10000)

# plot trajectory
plot(sim.rw, type = "l", asp = 1, main = "Random walk")
@

\code{state.RW} is a shortcut function for defining a totally random movement state, with unit step length.
Now let's try with a more interesting movement type, a simple Correlated Random Walk, where the direction taken in one step is correlated with the direction of the previous step.
For this you have the shortcut function \code{state.CRW}, to which you must provide the amount of correlation (here we use 0.98).
This parameter varies between [0, 1], being 0 no correlation (yielding a random walk state) and 1, a 100\% correlation (step direction does not change, it's always the same as the previous step). Obviously, \code{state.RW()} is a shortcut for \code{state.CRW(0)}.

<<simriv-2, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
# define a species with a single-state movement type
# characterized by a correlated random walk with
# correlation=0.98
c.rand.walker <- species(state.CRW(0.98))

# simulate one individual of this species
# 10000 simulation steps
sim.crw <- simulate(c.rand.walker, 10000)

plot(sim.crw, type = "l", asp = 1, main = "Correlated Random walk")
@

Additionally, you have a third shortcut \code{state.Resting()}, which corresponds to a state where the individual is stopped.
These three shortcut functions are the bricks with which you construct any complex multistate movement. You can combine them with \code{+} to define a multistate movement, see next topic.

All simulations above were conducted with the step length = 1, which is the default. You may set the desired step length for any state simply by adding a number to the state definition,
or you may set the same step length for all states by adding a number to the species itself.

<<simriv-3, fig=FALSE , echo=TRUE>>=
# define a species with a correlated random walk
# and step length = 15
c.rand.walker.15 <- species(state.CRW(0.98) + 15)

# which, in single-state species, is the same as:
c.rand.walker.15 <- species(state.CRW(0.98)) + 15
@

\section{Multi-state movement simulations}
Multi-state movements require specifying the probabilities of transition between the movement states.
This transition matrix, which is a parameter you specify when defining the species, has an overwhelming importance in the final movement pattern.
Formally, it is just a square matrix with all values in the range [0, 1], and whose rows must sum to one (but not columns).
It should be read row-wise, that is, the cell at row 2 column 3 defines the probability of the individual changing from state \#2 to state \#3.

As an example, let's simulate a two-state movement, a Lévy-like walker, i.e. a walker who alternates between random walks and correlated random walks.
We can define the multi-state movement by combining the two states like \code{state.RW() + state.CRW(0.98)}.
Then, we have to provide the probabilities of changing from state \#1 to state \#2 and from state \#2 to state \#1.
A convenience function, \code{transitionMatrix}, is provided to build such matrix. In the example below, we define the probabilities: \#1 -> \#2: 0.005; \#2 -> \#1: 0.01
We also set the step length for both states to \code{25}.

<<simriv-4, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
# a Lévy walker can be approximated by a two-state walker
# composed of a random walk state and a correlated
# random walk state.
levy.walker <- species(state.RW() + state.CRW(0.98)
  , trans = transitionMatrix(0.005, 0.01)) + 25

sim.lw <- simulate(levy.walker, 10000)

plot(sim.lw, type = "l", asp = 1, main = "Lévy-like walker")
@

The same logic applies to any number of states, but obviously, the transition matrix quickly gets large. See \code{help(transitionMatrix)} for details.


\section{Simulating in heterogeneous environments}
\code{SiMRiv} can be used to simulate movements in an homogeneous environment, in which case you don't need to import data.
However, if you want to conduct simulations in heterogeneous environments (which includes riverscapes), a resistance raster must be given as input to the simulation procedure.
This raster defines, for all pixels in space, the propensity of the individuals to move within/into each pixel (see details and discussion in \code{help(simulate)}).
Any object of class \code{RasterLayer} (from the \code{raster} package) with values in the range [0, 1] can be used, where 0 means a pixel with no resistance and 1 a pixel with 'infinite' resistance (i.e. where the individual cannot move).

\subsection{Data import}{
\code{SiMRiv} provides a helper function \code{resistanceFromShape} to aid the conversion from vector data (line and polygon shapefiles) to a resistance raster, optionally combining multiple rasters into one (e.g., a physical resistance raster and a resource distribution raster).
It is basically a wrapper for the functionality provided by the \code{raster} package, combining multiple features in one function:

\begin{enumerate}
\item Rasterize polygon or line shapefiles with a user-given pixel resolution
\item Assign resistance values to a categorical field in the shapefile or directly read values from a numerical field
\item Assign a background value for areas not covered by the polygons or lines
\item Create a buffer around lines (or polygons), optionally variable in size
\item Stack multiple shapefiles into one combined raster
\end{enumerate}

Its use is exemplified below.
}

\subsubsection{Importing shapefiles to use as resistance raster}
The following example is the simplest case, it creates a binary resistance raster with 100m resolution, assigning resistance 0 to areas
covered by polygons in the given shapefile and resistance 1 to areas not covered. You can change these values with the parameters \code{field} (defaults to 0)
and \code{background} (defaults to 1). The same works for line shapefiles.

<<simriv-5, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
resistance <- resistanceFromShape("../inst/doc/landcover.shp"
  , res = 100)
plot(resistance, axes = F)#, mar = c(0, 0, 0, 2))
@

The following example creates a resistance raster with 100m resolution by importing a polygon shapefile while assigning different resistance values to each land cover class (given by the \code{mapvalues} parameter)
provided in the shapefile field \code{coverclass}. All pixels not covered by a polygon are assigned a resistance of 0.9.
Note that you can add a margin around the extent of the shapes (here, we used a 3000 m margin), to minimize the boundary effect in simulations:
during simulations, all area outside the extent of the resistance raster is given resistance 1, which makes the simulated individuals never move out of this rectangle, thus creating a boundary effect.

<<simriv-6, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
resistance <- resistanceFromShape("../inst/doc/landcover.shp"
  , res = 100, field = "coverclass", mapvalues = c(
    "forest" = 0.5, "urban" = 1, "dam" = 0
    , "shrubland" = 0.75), background = 0.9, margin = 3000)

plot(resistance, axes = F, mar = c(0, 0, 0, 2))
@

The same applies for line shapefiles. In this case, it is useful to make a buffer around lines, otherwise the rasterized
version may be too thin for the simulation to adequately proceed.
Note that, by default, if no buffer is used, the rasterization of lines 'projects' the lines into all cells that are touched by the line (see \code{help(rasterize)} of the \code{raster} package), which results in 1-pixel wide features.
This should be avoided; always make sure that the thinnest line elements are at least 3 pixel wide in the resistance raster.
In this example with a river (using a buffer of 150m), resistance is manually assigned according to the river order field '\code{Order}' of the shapefile (higher resistance values for lower stream order sectors - i.e., the species is assumed to use main river sectors more than tributaries):

<<simriv-7, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
resistance <- resistanceFromShape("../inst/doc/river-sample.shp"
  , res = 100, field = "Order", mapvalues = c("2" = 0
    , "3" = 0.2, "4" = 0.4, "5" = 0.6, "6" = 0.8)
  , buffer = 150, background = 0.95, margin = 3000)

plot(resistance, axes = F, mar = c(0, 0, 0, 2))
@

A better, and possibly more realistic, option for rivers, instead of varying the resistance,
would be to use a buffer proportional to the river order (alternatively, both solutions may be applied).
In that case, we're better off loading the shape separately:

<<simriv-8, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
# load shapefile
river.shape <- shapefile("../inst/doc/river-sample.shp")

# below you can provide the shapefile filename, or the
# R shapefile object itself
resistance <- resistanceFromShape(river.shape, res = 100
  , buffer = (9 - river.shape@data$Order) ^ 3
  , background = 0.95, margin = 3000)

# buffer here is just some magical function to convert river
# order into a meaningful value in the [0, 1] range!

plot(resistance, axes = F, mar = c(0, 0, 0, 2))
@

\subsubsection{Combining multiple shapefiles or rasters in one resistance raster}
Often one needs to combine data from different shapefiles into a combined resistance raster. The following example places the river
on top of the land cover shape, using the parameter \code{baseRaster}.
The extent is automatically adjusted to fit all provided shapefiles' extents (plus the optional margin).
Note also that, if we want a constant resistance value for all lines/polygons in a shape, we may specify the value with the parameter
\code{field} (as is done below in \code{river.landcover}), instead of giving a field name (as is done below in \code{landcover}).

<<simriv-9, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
landcover <- resistanceFromShape("../inst/doc/landcover.shp"
  , res = 50, field = "coverclass", mapvalues = c(
    "forest" = 0.5, "urban" = 1, "dam" = 0
    , "shrubland" = 0.75), background = 0.95)

river.landcover <- resistanceFromShape("../inst/doc/river-sample.shp"
  , baseRaster = landcover, buffer = 100, field = 0
  , background = 0.95, margin = 3000)

plot(river.landcover, axes = F, mar = c(0, 0, 0, 2))
@

\subsection{Conducting simulations on a resistance raster}
When simulating in heterogeneous environments, one further parameter must be taken into account, which is how the species perceives the environment to make its movement decisions.
This is implemented as the concept of \textbf{perception window}: the area around the individual's current position, which it takes into account for making decisions.
As of version \Sexpr{version$Version}, this is implemented as a circle centered on the individual's position, with a user-specified radius.

During simulations, at each step, the turning angles of the individuals will be biased towards lower resistance areas, and this is evaluated only within the radius of the perception window.
This parameter also has an overwhelming importance in the resulting movement patterns.
A species with a wider perception window will be attracted to lower resistance areas, even if it has to cross high resistance areas, because it 'sees' farther.
Conversely, a species with a small perception window will not 'see' those lower resistance areas, so it will be detained by high resistance areas.
This can have important consequences, for example, when simulating amphibious species in a river: the size of the perception window will determine how likely the individuals will take overland shortcuts between river segments.

In order to allow more flexibility, the perception window is an attribute of each state (not of the species).
For ease of use, the size of the perception window of a state can be set simply by multiplying the state by a number, for example \code{state.RW() * 1000} will define a random walk state with a perception window of 1000 m.
If you want to set the same value for all the states of a species, you can directly multiply the species by a number, e.g. \code{levy.walker * 1500} will set the perception window of both states of the Lévy-like walker to 1500 m.

In the next example, we simulate a Lévy-like walker in a riverscape, assuming an amphibious species, i.e. that moves mainly in water but may also walk overland if needed.
This example also demonstrates how to set the starting coordinates to a random pixel with given resistance value(s).

<<simriv-10, fig=TRUE , echo=TRUE, grdevice=my.Swd>>=
# set starting coordinates anywhere within the river
init = xyFromCell(river.landcover, sample(which(values(river.landcover) == 0), 1))


# adding a number to a species is a shortcut for setting
# the step lengths of all states
# multiplying is a shortcut for setting the perception window radius
levy.walker <- (levy.walker + 10) * 1000

sim.lw.river <- simulate(levy.walker, 40000
  , resist = river.landcover, coords = init)

# plot resistance
plot(river.landcover, axes = F, mar = c(0, 0, 0, 2)
  , ylim = range(sim.lw.river[, 2]), xlim = range(sim.lw.river[, 1]))

# plot trajectory on top of resistance
lines(sim.lw.river)

#image(river.landcover, maxpixels=Inf, asp=1, zlim=c(0,1)#, col=c(gray(seq(1, 0.6, len=20)), "#990000")
#	, ylim = range(sim.lw.river[, 2]), xlim = range(sim.lw.river[, 1]), axes = F, xlab = NA, ylab = NA)
@

\section{Advices for conducting bias-free simulations}
\subsection{Step lengths and resolution}
When using resistance rasters, it is important to adequately choose the step length. You should consider the size of the raster features when choosing an appropriate step length:
if the step length is larger than the smaller features (say, the width of a river), the individuals will jump over those features, and the simulation will not be correct.
Step length should always be small, close to the real steps of the simulated species, and much smaller than the smallest landscape features.
This is because the \code{SiMRiv} simulation algorithm was developed in the logic of conducting infinitesimal simulations.
If you want to have simulated data which is comparable to real tracking data, you must downsample the simulation results with the function \code{sampleMovement}.

\section{References}
Turchin, P. 1998. Quantitative analysis of movement: measuring and modeling population
redistribution in animals and plants (Vol. 1). Sinauer Associates, Sunderland, MA.


TBC...

\section{To do list}
This section is mainly intended as an authors’ to-do list. As such, you may skip it.

The software in its current version does not allow for:

\begin{enumerate}
\item parameter estimation through maximum likelihood (e.g., Morales et al 2004; Van de Kerk et al 2015; Patterson et al 2016; ...);
\item spatial bias (e.g., to fit a biased random walk);
\item multiple interacting individuals' simulations;
\item differentiate between physical resistance and habitat suitability;
\item turning angle in function of the habitat suitability (i.e., currently, it depends on resistance values. In future versions, we'd like to allow it to be dependent on other features - e.g., habitat type);
\item other distributions for turning angles and steplength (currently, we allow ..., ...);
\item memory effects.
\end{enumerate}

Also, although they would be relatively easy and straightforward to implement, several potentially useful functions are not yet implemented. They include:
\begin{enumerate}
\item calculate the shortest distance among points along a linear network (e.g., river, road) - useful, for instance, to define linear home range extensions of species moving in linear habitats (e.g., fish or otters);
\item calculate core areas (areas of more intense use) of species moving in linear habitats;
\item estimate linear home ranges (e.g., linear kernel density estimation);
\item step selection function analysis applied to species moving in linear habitats;
\item generate random points along linear networks;
\item interpolation along lines.
\end{enumerate}

However, we programmed the software in order to be possible to implement the above-mentioned features in a near future. We highly encourage interested programmers to join our project and help us developing and further extending the package.

\end{document}

